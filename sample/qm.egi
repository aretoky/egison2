(load "./etc/lib/base.egi")
(load "./etc/lib/number.egi")
(load "./etc/lib/collection.egi")

(define $Bit
  (type
    {[$var-match (lambda [$tgt] {tgt})]
     [$inductive-match
      (deconstructor
        {[on []
          {[<on> {[]}]
           [_ {}]}]
         [off []
          {[<off> {[]}]
           [_ {}]}]
         [X []
          {[<X> {[]}]
           [_ {}]}]})]
     [$equal?
      (lambda [$val $tgt]
        (match [val tgt] [Bit Bit]
          {[[<on> <on>] <true>]
           [[<off> <off>] <true>]
           [[<X> <X>] <true>]
           [[_ _] <false>]}))]}))

(define $bit-not
  (lambda [$b]
    (match b Bit
      {[<on> <off>]
       [<off> <on>]
       [_ b]})))

(define $isHD1?
  (lambda [$v1 $v2]
    (match [v1 v2] [(List Bit) (List Bit)]
      {[[<join $hs <cons <on> $ts>> <join ,hs <cons <off> ,ts>>] <true>]
       [[<join $hs <cons <off> $ts>> <join ,hs <cons <on> ,ts>>] <true>]
       [[_ _] <false>]})))

(test (isHD1? {<off> <on> <off>} {<off> <off> <off>}))
(test (isHD1? {<off> <off> <off>} {<off> <off> <off>}))

(define $merge
  (lambda [$v1 $v2]
    (match [v1 v2] [(List Bit) (List Bit)]
      {[[<join $hs <cons <on> $ts>> <join ,hs <cons <off> ,ts>>] {@hs <X> @ts}]
       [[<join $hs <cons <off> $ts>> <join ,hs <cons <on> ,ts>>] {@hs <X> @ts}]})))

(test (merge {<off> <on> <off>} {<off> <off> <off>}))

(define $input {{<off> <on> <off> <off>}
                {<on> <off> <off> <off>}
                {<on> <on> <off> <off>}
                {<on> <off> <on> <off>}
                {<on> <off> <off> <on>}
                {<on> <on> <on> <off>}
                {<on> <off> <on> <on>}
                {<on> <on> <on> <on>}})

(define 